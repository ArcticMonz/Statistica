<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_HTML"></script>
    <title>Homework 1 - Statistica 24/25</title>
    <!-- Bootstrap CSS -->
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            padding-top: 56px; /* Adjust padding for the fixed navbar */
            display: flex;
            flex-direction: column;
            min-height: 100vh; /* Make sure the body takes the full height */
        }

        main {
            flex: 1; /* Allow main to grow and take available space */
        }

        header {
            padding-top: 100px; /* Space from the top */
            padding-bottom: 100px; /* Space at the bottom */
            display: flex;
            flex-direction: column;
            justify-content: center; /* Center content vertically */
            align-items: center; /* Center content horizontally */
            text-align: center; /* Center text */
        }
    </style>
</head>
<body>

    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light fixed-top">
        <a class="navbar-brand" href="#">Statistics</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav">
                <li class="nav-item active">
                    <a class="nav-link" href="index.html">Home <span class="sr-only">(current)</span></a>
                </li>
            </ul>
        </div>
    </nav>

    <!-- Header -->
    <header class="bg-primary text-white">
        <h1>Homework 3</h1>
        <p>Details and insights on Homework 3 for the Statistics course.</p>
    </header>

    <!-- Main Content -->
    <main class="container mt-4">
        <div class="row">
            <div class="col-md-12">
                <h4>Why the Median Minimizes the Sum of Absolute Deviations</h4>
    
    <p>
        Given a set of data points \( x_1, x_2, \dots, x_n \) (sorted in increasing order without loss of generality), 
        we want to find the value of \( c \) that minimizes the function:
    </p>

    \[
    S(c) = \sum_{i=1}^{n} |x_i - c|
    \]

    <h4>1. Analyzing the behavior of \( S(c) \)</h4>
    <p>
        The function \( S(c) = \sum_{i=1}^{n} |x_i - c| \) sums the absolute deviations of each data point \( x_i \) from \( c \).
        The absolute value function behaves as follows:
    </p>
    \[
    |x_i - c| = 
    \begin{cases} 
      x_i - c & \text{if } c \leq x_i \\
      c - x_i & \text{if } c > x_i 
    \end{cases}
    \]

    <p>This means that \( S(c) \) changes its form depending on where \( c \) lies in relation to the \( x_i \)'s.</p>

    <h4>2. Behavior of \( S(c) \) as \( c \) moves</h4>
    <ul>
        <li>
            When \( c \) is smaller than most of the \( x_i \)'s (on the far left of the data), increasing \( c \) tends 
            to decrease the larger positive deviations and increase the smaller negative ones. Hence, as \( c \) increases, the total sum \( S(c) \) decreases.
        </li>
        <li>
            When \( c \) is larger than most of the \( x_i \)'s (on the far right), decreasing \( c \) tends to decrease the larger positive 
            deviations and increase the smaller negative ones. Hence, as \( c \) decreases, the total sum \( S(c) \) decreases.
        </li>
    </ul>

    <h4>3. Subgradient Analysis</h4>
    <p>
        Even though the absolute value function is not differentiable at every point, we can use the idea of subgradients. The subgradient of the 
        absolute value function \( |x_i - c| \) is:
    </p>

    \[
    \text{subgradient of } |x_i - c| = 
    \begin{cases} 
      -1 & \text{if } c < x_i \\
      0 & \text{if } c = x_i \\
      1 & \text{if } c > x_i 
    \end{cases}
    \]

    <p>
        Now, consider the derivative (or subgradient) of \( S(c) \):
    </p>

    \[
    S'(c) = \sum_{i=1}^{n} \text{sgn}(x_i - c)
    \]

    <p>Where \( \text{sgn}(x_i - c) \) is the sign function, which outputs -1, 0, or 1 based on the relative value of \( x_i \) and \( c \).</p>

    <ul>
        <li>When \( c \) is less than the median, more than half of the terms contribute positive values (since \( x_i - c > 0 \)).</li>
        <li>When \( c \) is greater than the median, more than half of the terms contribute negative values (since \( x_i - c < 0 \)).</li>
        <li>The point where the sum of the subgradients changes sign is exactly when \( c \) is the <strong>median</strong>.</li>
    </ul>

    <h4>4. Minimizing the Sum of Absolute Deviations</h4>
    <p>
        To minimize \( S(c) \), we seek the value of \( c \) such that the sum of the subgradients equals zero, or equivalently, 
        the number of terms for which \( x_i > c \) equals the number of terms for which \( x_i < c \). This balance occurs precisely 
        when \( c \) is the <strong>median</strong> of the data set. At the median:
    </p>

    <ul>
        <li>Half of the data points are smaller than \( c \), and half are larger than \( c \), minimizing the total sum of deviations.</li>
    </ul>

    <h4>Conclusion</h4>
    <p>
        The median minimizes the sum of absolute deviations because it equally balances the number of data points on either side of it, minimizing the 
        total sum of positive and negative deviations. Any other value of \( c \) would shift this balance and increase the sum of absolute deviations.
    </p>

    <hr>

    <h4>Different Ways to Define Location Statistics</h4>
    
    <p>
        Measures of "location," also called central tendency or center, represent the "typical" value of a data distribution. These statistics synthesize data with a single number, providing insight into where the center or balance of the data lies. Below are the different conceptual ways to define location statistics, each with a distinct approach.
    </p>

    <h4>1. Arithmetic Mean</h4>
    <p>
        The <strong>arithmetic mean</strong>, or average, is the most common measure of central tendency, defined as:
    </p>
    \[
    \mu = \frac{1}{n} \sum_{i=1}^{n} x_i
    \]
    <p>
        It is the sum of all values divided by the number of values, minimizing the sum of squared deviations from itself. It is particularly effective for symmetric distributions.
    </p>

    <h4>2. Median</h4>
    <p>
        The <strong>median</strong> is the middle value in a sorted dataset. It divides the dataset into two equal halves and minimizes the sum of absolute deviations:
    </p>
    \[
    \text{Median} = \arg\min_{c} \sum_{i=1}^{n} |x_i - c|
    \]
    <p>
        The median is robust to outliers and gives a better summary of skewed data than the mean.
    </p>

    <h4>3. Mode</h4>
    <p>
        The <strong>mode</strong> is the value that appears most frequently in the dataset. In continuous distributions, the mode is the point where the probability density function (PDF) is maximized.
    </p>
    <p>
        The mode is particularly useful when you need to identify the most frequent value in a dataset or the peak in a distribution.
    </p>

    <h4>4. Geometric Mean</h4>
    <p>
        The <strong>geometric mean</strong> is defined as the nth root of the product of n values:
    </p>
    \[
    \text{Geometric Mean} = \left( \prod_{i=1}^{n} x_i \right)^{1/n}
    \]
    <p>
        It is useful when the data involve multiplicative processes, such as growth rates or ratios.
    </p>

    <h4>5. Harmonic Mean</h4>
    <p>
        The <strong>harmonic mean</strong> is another measure for averaging rates or ratios and is defined as:
    </p>
    \[
    \text{Harmonic Mean} = \frac{n}{\sum_{i=1}^{n} \frac{1}{x_i}}
    \]
    <p>
        The harmonic mean gives greater weight to smaller values and is often used in situations where small numbers dominate, such as averaging speeds.
    </p>

    <h4>6. Trimmed Mean</h4>
    <p>
        The <strong>trimmed mean</strong> removes a fixed percentage of the smallest and largest data points before calculating the mean, making it more robust to outliers.
    </p>
    <p>
        It is especially useful when a dataset contains extreme values that might distort the mean.
    </p>

    <h4>7. Weighted Mean</h4>
    <p>
        The <strong>weighted mean</strong> allows each data point to have a different weight, reflecting its relative importance:
    </p>
    \[
    \text{Weighted Mean} = \frac{\sum_{i=1}^{n} w_i x_i}{\sum_{i=1}^{n} w_i}
    \]
    <p>
        It is useful when some data points should contribute more to the average than others.
    </p>

    <h4>8. Midrange</h4>
    <p>
        The <strong>midrange</strong> is the average of the maximum and minimum values in the dataset:
    </p>
    \[
    \text{Midrange} = \frac{x_{\text{max}} + x_{\text{min}}}{2}
    \]
    <p>
        This measure is highly sensitive to outliers but provides a quick sense of the range’s midpoint.
    </p>

    <h4>9. Quantiles and Percentiles</h4>
    <p>
        <strong>Quantiles</strong> divide the data into intervals. For instance, the 50th percentile is the median, the 25th percentile is the lower quartile, and the 75th percentile is the upper quartile.
    </p>
    <p>
        Quantiles give insights into how data is distributed across different thresholds.
    </p>

    <h4>10. Fréchet Mean (Barycenter)</h4>
    <p>
        The <strong>Fréchet mean</strong> generalizes the mean to non-Euclidean spaces. It minimizes the sum of squared distances in a given metric space:
    </p>
    \[
    \text{Fréchet Mean} = \arg\min_{c} \sum_{i=1}^{n} d(x_i, c)^2
    \]
    <p>
        This concept is useful for complex data, such as points on a sphere or in a manifold.
    </p>

    <h4>11. M-estimators</h4>
    <p>
        <strong>M-estimators</strong> generalize the mean by minimizing functions of deviations rather than simple sums of squares or absolute values. An M-estimator minimizes a function \( \rho(x_i - c) \):
    </p>
    \[
    \text{M-estimator} = \arg\min_{c} \sum_{i=1}^{n} \rho(x_i - c)
    \]
    <p>
        These estimators are robust and can be tailored for specific types of data distributions.
    </p>

    <h4>12. Center of Mass (for Weighted Data)</h4>
    <p>
        The <strong>center of mass</strong> is another way to define the center of a distribution when dealing with weighted data. It is calculated as:
    </p>
    \[
    \text{Center of Mass} = \frac{\sum_{i=1}^{n} m_i x_i}{\sum_{i=1}^{n} m_i}
    \]
    <p>
        This measure emphasizes the "mass" (or importance) of each data point and is widely used in spatial and physical data analysis.
    </p>

    <hr>

    <h2>Practice</h2>
    <h4>Simulation Settings</h4>
    <form id="settingsForm">
        <label for="numServers">N parameter (n):</label>
        <input type="number" id="numServers" name="numServers" min="1" value="5000" required><br><br>
        
        <label for="numAttackers">Number of Attackers (m):</label>
        <input type="number" id="numAttackers" name="numAttackers" min="1" value="5" required><br><br>
        
        <label for="lambda">Lambda:</label>
        <input type="number" id="lambda" name="lambda" min="0" step="0.1" value="1" required><br><br>
        
        <button type="submit">Run Simulation</button>
    </form>

    <canvas id="penetrationChart" width="800" height="400"></canvas>
    <canvas id="distributionChart" width="800" height="200" style="margin-top: 30px;"></canvas>

    <script>
        const penetrationCtx = document.getElementById('penetrationChart').getContext('2d');
        const distributionCtx = document.getElementById('distributionChart').getContext('2d');
        let penetrationChart, distributionChart;

        // Function to simulate cumulative penetration
        function simulateCumulativePenetration(n, m, p) {
            let results = Array(m).fill().map(() => [0]);
            let penetrationCounts = Array(m).fill(0);

            for (let i = 0; i < m; i++) {
                let cumulative = 0;
                for (let j = 0; j < n; j++) {
                    if (Math.random() < p) {
                        cumulative += 1;
                    }
                    results[i].push(cumulative);
                }
                penetrationCounts[i] = cumulative;
            }

            // Count number of attackers that penetrated a specific number of servers
            const distribution = {};
            for (let count of penetrationCounts) {
                distribution[count] = (distribution[count] || 0) + 1;
            }

            return { results, distribution };
        }

        // Function to create or update the penetration chart
        function updatePenetrationChart(n, m, lambda) {
            const p = lambda / n; // Calculate p from lambda and n
            const { results, distribution } = simulateCumulativePenetration(n, m, p);

            // Create labels in terms of "1/n", "2/n", ..., "n/n"
            const labels = Array.from({ length: n }, (_, i) => `${i + 1}/${n}`);
            const datasets = results.map((result, index) => ({
                label: `Attacker ${index + 1}`,
                data: result,
                borderColor: `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.7)`,
                fill: false,
                stepped: true
            }));

            // Find the maximum cumulative penetration to adjust y-axis with padding
            const maxPenetration = Math.max(...results.flat());
            const yMax = Math.ceil(maxPenetration * 1.2);  // Add 20% padding for better visualization

            // Update or create the line chart
            if (penetrationChart) {
                penetrationChart.data.labels = ['Start', ...labels];
                penetrationChart.data.datasets = datasets;
                penetrationChart.options.scales.y.max = yMax; // Set dynamic max with padding
                penetrationChart.update();
            } else {
                penetrationChart = new Chart(penetrationCtx, {
                    type: 'line',
                    data: {
                        labels: ['Start', ...labels],
                        datasets: datasets
                    },
                    options: {
                        scales: {
                            y: {
                                type: 'linear',
                                min: 0,
                                max: yMax, // Set dynamic max value with padding
                                position: 'left'
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Step (Fraction of n)'
                                }
                            }
                        },
                        plugins: {
                            tooltip: { mode: 'index', intersect: false }
                        }
                    }
                });
            }

            // Generate the distribution chart with the updated data
            updateDistributionChart(distribution, n);
        }

        // Function to create or update the distribution chart
        function updateDistributionChart(distribution, maxServers) {
            const distributionLabels = Array.from({ length: maxServers + 1 }, (_, i) => `${i}`);
            const distributionData = distributionLabels.map(label => distribution[label] || 0);

            if (distributionChart) {
                distributionChart.data.labels = distributionLabels;
                distributionChart.data.datasets[0].data = distributionData;
                distributionChart.update();
            } else {
                distributionChart = new Chart(distributionCtx, {
                    type: 'bar',
                    data: {
                        labels: distributionLabels,
                        datasets: [{
                            label: 'Number of Attackers',
                            data: distributionData,
                            backgroundColor: 'rgba(0, 123, 255, 0.7)',
                            borderColor: 'rgba(0, 123, 255, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        scales: {
                            y: {
                                type: 'linear',
                                min: 0,
                                ticks: { precision: 0 }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Servers Penetrated'
                                }
                            }
                        },
                        plugins: {
                            tooltip: { mode: 'index', intersect: false }
                        }
                    }
                });
            }
        }

        // Form submission handler
        document.getElementById('settingsForm').addEventListener('submit', function(event) {
            event.preventDefault();
            const n = parseInt(document.getElementById('numServers').value);
            const m = parseInt(document.getElementById('numAttackers').value);
            const lambda = parseFloat(document.getElementById('lambda').value);
            updatePenetrationChart(n, m, lambda);
        });

        // Initial render
        updatePenetrationChart(365, 5, 1);
    </script>

            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="bg-light text-center py-4">
        <p>&copy; 2024 My Blog. All Rights Reserved.</p>
    </footer>

    <!-- Bootstrap JS and dependencies -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
</body>
</html>
